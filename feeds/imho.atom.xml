<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom"><title></title><link href="http://blog.zoomquiet.io/" rel="alternate"></link><link href="http://blog.zoomquiet.io/feeds/imho.atom.xml" rel="self"></link><id>http://blog.zoomquiet.io/</id><updated>2013-12-24T00:00:00+08:00</updated><entry><title>On object-oriented programming</title><link href="http://blog.zoomquiet.io/imho/131224-yw-on-oop.html" rel="alternate"></link><updated>2013-12-24T00:00:00+08:00</updated><author><name>Zoom.Quiet</name></author><id>tag:blog.zoomquiet.io,2013-12-24:imho/131224-yw-on-oop.html</id><summary type="html">&lt;p&gt;via: http://yinwang0.wordpress.com/2013/12/24/on-object-oriented-programming/&lt;/p&gt;
&lt;p&gt;The programmers’ world is full of fads and superstitions. Every now and then there will be somebody come up and announce: “I can save the world!” No matter how bad the ideas are, there will always be followers, and the ideas soon become their religion. They then develop their community or camp, try to make the rest of the world adopt those ideas, and try to make the ideas live forever.&lt;/p&gt;
&lt;p&gt;Whenever you criticize a programming language or paradigm, people would think you are a proponent of some other language or paradigm. Since I wrote the article pointing out the drawbacks of purely functional programming and monads, some people have apparently taken me as a proponent of object-oriented programming. That’s far from the case. I don’t like OO at all. I use almost none of the OO techniques even when I write programs in Java.&lt;/p&gt;
&lt;p&gt;I have a scientific mind. I do research on programming languages and I make some of my own. I have implemented almost every feature in every language. So programming languages have no power upon me. I play with them like toys. I never see a language or a paradigm as a whole. I can dissect them and take the good parts that I liked, and discard the parts that don’t work well.&lt;/p&gt;
&lt;p&gt;Actually in the first version of the previous article I also criticized OOP, but I soon realized that it may not be an interesting topic. I have known the shortcomings of OOP and associate design pattens etc for many years and I thought that most programmers know them, and there is no need to write about them. It turns out that I was wrong. I have lived in my nice little world for too long and forgot how confusing the world can be.&lt;/p&gt;
&lt;p&gt;I just saw this InfoQ talk by Gilad Bracha today. He dislikes the purely functional cult as much as I do, but unlike me, he has subscribed to another cult that is OOP. Although he made some good points, the general message I got from the talk was that OOP the “one true king” is going to rule the world, and FP will be deconstructed and serve as a subordinate of it. OOP will live forever. This is ridiculous.&lt;/p&gt;
&lt;p&gt;FP has its problems, but it deserves a lot more respect than this. Although I dislike some purely functional language’s cult-like culture, FP in general is highly valued. FP taught me a lot more and contains a lot more value than OOP. The education I received from some of the best FP people made me a better programmer. Even when I use a OO language, I avoid its shortcomings and write in a much cleaner way than the usual OO style. Some OO languages have been learning (or stealing) from FP languages for long and benefitted from it. To make a living, some highly educated FP people work on OO languages, make good compilers or tools for them. I feel terrible that somebody talks about FP that way.&lt;/p&gt;
&lt;p&gt;Gilad criticized some bad designs in FP, but highly promoted the bad designs from OOP, to the degree of calling them “the one true way”. Many aspects of OOP have been bringing harm to the software industry and computer science education for long, but he didn’t mentioned them. The more I forget about those ideas from OO, the simpler and better my code becomes. I thought many people have learned these lessons, but it looks that’s not true.&lt;/p&gt;
&lt;p&gt;Thus I realized that my original criticism of OOP had some value, and I decided to write a dedicated article about it.&lt;/p&gt;
&lt;h1 id="is-everything-an-object"&gt;Is everything an object?&lt;/h1&gt;
&lt;p&gt;“Everything is an object” is the favorite dogma of OOP. Now let’s take a look to see if it is true, or if it is a good idea to make it that way.&lt;/p&gt;
&lt;p&gt;The generally accepted definition of an object is a combination of “data fields (attributes that describe the object) and associated procedures known as methods.” Can you really fit everything into this model?&lt;/p&gt;
&lt;p&gt;First let’s look at the real world and see if this definition can capture everything. Cars, trees, animals may sometimes be thought of as objects, but what about a change of the objects’ position, their velocity and time? What methods do they have? Well, true believers of OOP may give you classes called Velocity or Time, with methods such as addition in them. But do velocity and time really contain these things you call “methods”? They don’t. Those are just your imagination. You can add the velocities or time, but how can velocities or time contain the addition procedure? This is like saying that the integers contain the CPU’s adders.&lt;/p&gt;
&lt;p&gt;So the most you can say is that “everything is an object” is a good way of thinking, but that is not true either. The definition of an object implies that a method can only belong to one object, but most of the time it doesn’t make sense thinking of functions as belonging to any object. Say we have the expression 1+2, does the operator ‘+’ belong to 1, or does it belong to 2? You have to make some arbitrary choice. Since you can make a choice, this means the ‘+’ operator doesn’t really belong to either of them. It is inherently outside of the objects.&lt;/p&gt;
&lt;p&gt;So thinking of some things as objects may be helpful, but thinking ofeverything as an object is neither true nor useful. Unfortunately, “everything is an object” has been taken as a dogma and the highest standard of OO language design. Some OO languages claim that everything is an object in them. Whenever you notice that something is not an object, somebody will try to make it one. You may succeed in that, but things get very complicated.&lt;/p&gt;
&lt;p&gt;The idealism of “everything is an object” is similar to the FP world’s “everything is a function”. Before computer science was conceived there was this thing called lambda calculus. Some people encoded everything including all numbers and all data structures — all in lambdas. One of the encodings of numbers is called the Church numeral. But unlike “everything is an object”, “everything is a function” has never become a dogma. It works in principle but nobody really use them for actual computation, because they are inefficient and they make things complicated.&lt;/p&gt;
&lt;p&gt;So “everything is an object” is in some sense on the same track of “everything is a function”, although to a lesser extent and uglier. Good thought exercise, but doesn’t really work well in practice.&lt;/p&gt;
&lt;h1 id="are-functions-objects"&gt;Are functions objects?&lt;/h1&gt;
&lt;p&gt;The original motivation of putting functions inside objects was to support GUI applications. You click on a button and some code (a callback) will be invoked. For the convenience of referring to the button that gets clicked, the callback takes the triggered object as its first argument. Since the callback does nothing more than this, it seems to be convenient to just store it inside the button. And thus we had an “object” which combines the attributes of the button and its method (the callback). Indeed it is convenient and a good idea. But the limited usage case of GUI applications can’t really justify a universal notion of “everything is an object”. Computer science often suffers from such over-generalizations.&lt;/p&gt;
&lt;p&gt;But even the above contains a subtle mistake: the callback in the button is not really a method. It is just a usual function. Very few procedures should be considered methods of an object, and most others are just functions. If you look carefully, most of the time the objects just serve as a namespace (or module) in which you can put data fields and functions. But those functions can also live on their own (such as addition of velocities or time). They just take the objects as inputs and produce some output. Only the functions that are most intimately connected to the fields and provide an “abstraction layer” should be considered methods. Most of those are “getters”, “setters” or “iterators”. Functions don’t necessarily belong to objects. They are not objects. They describe a change, transition or transformation of objects. They are external to the objects.&lt;/p&gt;
&lt;p&gt;In some languages such as Scala or Python, functions are also treated as objects. But they actually just wrapped the functions into an object, give them some name such as “apply” or “&lt;strong&gt;call&lt;/strong&gt;”, so that when the objects are “invoked”, you know which functions to call. But putting a function into an object doesn’t really mean functions are also objects, just like inviting friends to your house doesn’t make them your family.&lt;/p&gt;
&lt;h1 id="the-cost-of-excessive-abstraction"&gt;The cost of excessive abstraction&lt;/h1&gt;
&lt;p&gt;The major appeal of OOP is abstraction, but OO programmers usually overdo it. I know the value of abstraction. I build abstractions every day, in all kinds of languages. But OOP advocates a level of abstraction which makes programs hard to understand and hard to analyze. I often see Java programs with multiple levels of inheritance and overloading but doing very little. And worse, because there are so much code that doesn’t do real things, it is very hard to find out which part of the code is doing the thing you want.&lt;/p&gt;
&lt;p&gt;Whenever you complain about Java or C++, OO proponents will tell you that they are not authentic OO languages. They would ask you to take a look at Smalltalk. If Smalltalk’s ways are that good, why almost nobody is using Smalltalk now? Because there are real problems in its approach. The “authentic” OO style of Smalltalk promotes the notion of “extremely late binding”, which basically means that the meaning of the program constructs is determined as late as possible.&lt;/p&gt;
&lt;p&gt;Late binding means that you have a chance to swap out the underlying implementation without forcing the upper levels to change, but it also means that you are no longer sure what a piece of code means! When I look at expressions such as ’1+2′ and ‘if (t) then … else …’ in Java or C++, I at least know for sure that they mean an integer addition and an usual conditional. But I’m not sure about this in an “extremely late binding language”, because even the meaning of ‘+’ and ‘if” can be redefined. A similar problem happens to Lisp family languages’ macro systems. It is bad idea of giving the programmers the power of defining control structures, because soon your language will be abundant of quirky control structures designed by programmers who try to be clever.&lt;/p&gt;
&lt;p&gt;Abstraction is a good idea when used moderately, but when you do it in excess, it backfires. Not only does it make it hard for humans to understand the code, it makes automated analysis tools and compiler optimizations difficult or impossible to make. I built an advanced static analysis tool for Python called PySonar. It works okay in general, but under the premise that the programs don’t use the “deep magic” of Python (which are possibly learned from Smalltalk). If you do, there are all sorts of ways you can confuse the analysis, but for that I can do nothing to help. Nothing can analyze or optimize the code if you put expensive or undecidable computations into the abstraction layer.&lt;/p&gt;
&lt;p&gt;So is there any value of making those deep abstractions an option but not encouraged to use by usual programmers? There might be, but probably too little to offset the lost safety guarantee and performance.&lt;/p&gt;
&lt;h1 id="everything-is-an-actor"&gt;Everything is an actor?&lt;/h1&gt;
&lt;p&gt;In his talk, Gilad Bracha disagrees with the FP hypes such as monads and pattern matching (with some good points), but he over-valued the ways of OOP and the actor model. From the blog posts he refers to, you can see that he thinks of the actor model as the “one true way”.&lt;/p&gt;
&lt;p&gt;I’m always wary of such notion as “one true way” or “everything is…” I actually read Carl Hewitt’s actor model paper a long time ago and also some of his other concepts such as Direct LogicTM (Yes, there is a trademark sign on it). I didn’t really appreciate the papers and his way of writing, with the “dedicated to some-big-names” headlines, trademark signs and grand claims.&lt;/p&gt;
&lt;p&gt;The actor model suffers from the same drawbacks of OOP as I mentioned: over-abstraction and lacking of general expressiveness. There is no way a human being or an automated system can effectively reason about the programs if you build them at way. It hides bugs. Although the actor model may be useful in some cases, it is not really expressive and simple enough to nicely capture all computations. It has too much application-specific logic (which is essentially OOP) built in, thus it is not at the same universal level as lambda calculus or Turing machines.&lt;/p&gt;
&lt;h1 id="the-stupidity-of-oo-design-patterns"&gt;The stupidity of OO design patterns&lt;/h1&gt;
&lt;p&gt;It may not be inherent in all OO languages, but OO design patterns (such names as Factory, Facade, Flyweight, Singleton, Visitor etc) have been the major source of over-complication and confusion. Their origin was mostly due to the dogma of “everything is an object” and the lack of high-order functions (or the correct implementation of them).&lt;/p&gt;
&lt;p&gt;The design patterns are completely nonsense to me and I never used them. When I first heard about them I was already a PhD student at Cornell doing some PL research. I was curious about the book’s fame and borrowed one from the library. But I soon found a mapping from all those weird names to the programming techniques I have been using all the time. I don’t understand how such a book as GoF can ever be published which contains nothing but just giving new and weird names to existing programming techniques that I use every day. If you say the purpose of writing this book is to “improve communication of programmers”, then I would write a book and give new names to air, water and all kinds of food, in order to “improve the communication of all human beings”.&lt;/p&gt;
&lt;p&gt;Peter Norvig gave a talk on design patterns in 1998 pointing out most of the design patterns will be “transparent” once you have first-class functions. He was too polite to call design patterns nonsense or stupid, but that’s implied.&lt;/p&gt;
&lt;p&gt;Every time I remove a design pattern (some other people made) from PySonar, the code becomes simpler and more manageable. I just removed the last visitor pattern a few days ago, and I felt so relieved. They gave me nothing but extra work when they existed. I can do anything, including a lot more advanced things than those provided by visitor patterns, but without using them.&lt;/p&gt;
&lt;p&gt;I owe my insights into design patterns to some functional programming people. If you really want to understand the essence of OO design patterns, and how NOT to use them, take a look at this little book other than the GoF one.&lt;/p&gt;
&lt;h1 id="what-the-heck-is-oo"&gt;What the heck is OO?&lt;/h1&gt;
&lt;p&gt;If some concepts of FP are white elephants, then most of the OO concepts are emperor’s new clothes.&lt;/p&gt;
&lt;p&gt;“OO” has never been a coherent concept. In the beginning it claims to be able to save the world by having all those nice things such as abstract data types, inheritance, overloading, encapsulation etc etc. As those marketing hypes fail one after another, OO supporters make excuses. They started to claim that some elements, such as inheritance, are not the true element of OO.&lt;/p&gt;
&lt;p&gt;The meaning of “object-oriented” is always vague and shifting. OO supporters can change the term’s meaning at any time to their advantages. You can be called an OO language at one moment, and then be called a non-OO language just a few minutes later, depending on what they need. When they need to claim that “OOP rules the world”, they would say that you are an OO language because you have something which contains both data fields and procedures, thus satisfying the definition of an “object”. When you are criticized by users for your shortcomings, they would say that you are not an OO language because you don’t have “extremely late binding” etc etc, …&lt;/p&gt;
&lt;h1 id="the-harm-of-oop"&gt;The harm of OOP&lt;/h1&gt;
&lt;p&gt;Although purely functional programming has a cult-like culture, it at least contains something we can learn. On the contrary, OOP is almost pure stupidity and cult. In comparison to the recent popularity of FP, OOP has been there longer, so the harm is much deeper. Some years ago, almost every language tried to be OO just because of it is a good marketing word that the companies were looking for. Later on, many companies bought the concept of so-called “OO design patterns” and write convoluted code, and only by now some of them realized that they were wrong.&lt;/p&gt;
&lt;p&gt;The harm of OO is deep into education. It is destroying computer science departments. Many colleges use OO languages such as Java as their introductory language, which cause the students’ failure to learn the most essential concepts of programming.&lt;/p&gt;
&lt;p&gt;In industry, OO hasn’t really proved its effectiveness with evidence. Good systems may be built in a “OO language”, but the code is often written by people who understand the problems of OO and don’t embrace “everything is an object” or “design patterns”. All the good programmers use workarounds in OO languages and are essentially writing in a style that’s not really OO. So some OO language and its tools may be pretty successful, but the OO style has largely failed.&lt;/p&gt;
&lt;p&gt;OO encourages code reusing, but we want something expressive, bug-free and fast. The OO style and OO design patterns produce convoluted code which confuses even its own author. Lots of times people can’t bear with the bugs but can’t understand the code, thus they end up rewriting the code on their own.&lt;/p&gt;
&lt;p&gt;The programming languages world has cared too much about styles, paradigms and code reusing, this is why such things as OO and design patterns can have a chance to fool lots of people. Styles and paradigms may help, but they don’t solve actual problems. There really is no such “one true way” to follow as some people believe. Not only that OOP will not rule the world, it will leave very little impact on the future of programming.&lt;/p&gt;
&lt;p&gt;====================================================================&lt;/p&gt;
&lt;blockquote&gt;
&lt;blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;试理解&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/blockquote&gt;
&lt;/blockquote&gt;
&lt;p&gt;程序猿的世界充斥着各种时髦迷信.不时就有人跳出来吼:”俺能拯救世界!”诡异的是,无论多不靠谱的想法,总有追随者,并快速打造成全站的宗教,结成社区,尽量迫使其它所有人认同,以史这想法永存下去.&lt;/p&gt;
&lt;p&gt;当你开始批评某编程语言或是范式时,人们就认为你一定是另外某某党的拥趸. 自从俺写文章黒 纯函式 编程以及单子的问题后, 有的就以为俺已经投入到 OOP 的怀抱中了. 图样图森破,俺从来就没有尿过 OOP, 即便在使用JAVA 编程时.&lt;/p&gt;
&lt;p&gt;俺具备科学思想.进行过编程语言的研究,而且自行实现过一些. 在任何语言上俺都能实现几乎所有语言特性. 因此,编程语言已经蒙不住俺了.俺能象玩具一般把玩它们, 在俺眼中它们只是一堆零件,可以任意折腾,提取俺喜欢的,丢弃俺不屑的.&lt;/p&gt;
&lt;p&gt;其实以往文章有部分已经对 OOP 吐糟过了,但是,很快反应过来这可能不是个有趣的话题. 俺以为大多数程序猿已经对 OOP 以及关联的设计模式的缺陷,没必要强调了. 然而,事实证明是俺图样图森破了,在自个儿可爱的小世界中呆久了,容易忘记外面的混沌.&lt;/p&gt;
&lt;p&gt;刚看到今天 InfoQ 上 Gilad Bracha 的访谈 . 他象俺一样不是性能崇拜者, 但是,他已经是邪恶的OOP 教派成员了, 虽然传达了一些很好的意见,但是,整体上对于 OOP 是”真圣”, FP 将解构为 OOP 的下属, 而 OOP 将永存. 这就过了吼!&lt;/p&gt;
&lt;p&gt;FP 当然有自身的固有问题,但是它值得更多的尊重. 虽然俺不喜欢一些 纯函式 语言邪教般的文化, 但是 FP 具有很高的价值. FP 教了俺很多好东西,含有比 OOP 更多价值. 从那些 FP 程序员身上接受的教导令俺成为更好的程序员. 甚至当我使用一个 面向对象 的语言时, 俺也习惯性的在躲避其缺点, 使用更加简洁的方式来完成功能. 一些 面向对象的语言,其实一直在向 FP 窃取思想而从中受惠. 限于生计, 有些受过 FP 高级教育的程序员,却在为 面向对象的语言工作,为其编写更好的编译或其它工具. 这令俺细思恐极.&lt;/p&gt;
&lt;p&gt;Gilad 批评了一些FP 中不好的设计, 但鼓吹 OOP 的设计模式是 “唯一正当”的,这更加要命. 事实上 OOP 对计算机科学的教育以及软件产业已经造成了深远的伤害. 虽然俺自觉的忘记 OOP ,用更加简洁的方式改善代码. 原本以为大家都跟俺一样,但看来现实并非如此.&lt;/p&gt;
&lt;p&gt;故此,俺意识到,俺对OOP 的批评具有一定的价值,决定写下来, 好好聊聊.&lt;/p&gt;
&lt;h2 id="is-everything-an-object_1"&gt;一切都是对象 ? Is everything an object?&lt;/h2&gt;
&lt;p&gt;“一切皆对象” 这是OOP 们最喜欢的教条. 现在来谈谈这货是否真如其宣称的这么好.&lt;/p&gt;
&lt;p&gt;通常被接受的对象定义是: “数据字段”(描述对象的属性)以及关联方法 的结合体.
你真能在所有情景中适应这种模式嘛?&lt;/p&gt;
&lt;p&gt;首先来设想一下OOP 模式是否能对真实世界加以解释. 汽车/树木/动物 视作对象的话, 那么它们的位置/速度/时间的 变化 乍说? 有什么对应的方法? 好吧, OOP 信徒可能叫你将类称为 速度 或是 时间 然后将方法增加进去. 可是速度/时间真的含有这种称为”方法”的东西 ? 当然没有, 这不过是想象罢了. 你可以追加速度/时间,但是,怎么令其包含 加处理? 这简直就象说该整数包含 CPU 的加法器.&lt;/p&gt;
&lt;p&gt;哪,信徒们最常说的:”一切皆对象”只是种好的思维方法,但事实并非如此. 一个对象的定义意味着一个方法只能属于一个对象,但大部分时间此思想并没有作用于任何对象. 当我们论及表达式: 1+2 , 是否得说 “+” 属于 1 ,或是算 2 的? 你必须作出属性方法归属的选择,而选择本身就已经意味着 “+” 操作其实并不真正属于任何一个对象,而是固有在对象之外的.&lt;/p&gt;
&lt;p&gt;只能说 有些 事儿上对象是有帮助的,而 一切 皆对象这事儿即不真实也无用. 悲摧的是, “一切皆对象” 已经成为面向对象语言设计的最高教条. 一些面向对象语言声称在其内部真的一切都是对象. 若你意识到什么不是对象时,就有人会跳出来整成对象. 当然聪明人可以作到这点,只是事儿就变的复杂起来.&lt;/p&gt;
&lt;p&gt;“一切皆对象” 的理想完全类似 FP 世界里 “一切皆函式” . 以前计算机科学称这种构想叫 lambda算子(lambda calculus). 有人就在编码时,将所有数字/数据结构都给包含在 lambda 中了.而这种包含了一切的东西叫Church numeral. 但是,相比 “一切皆对象”, “一切皆无函式” 复合材料没有教条化过. 这只是在理论上是可行的,但是,在实际工程中没有人这么折腾,因为这会令事儿变的复杂,而且效率低下.&lt;/p&gt;
&lt;p&gt;因此”一切皆对象” 在某种意义上是 “一切皆函式” 的同位素, 理论上是美好的,但是从未在实际工程中很好的工作过.&lt;/p&gt;
&lt;h2 id="are-functions-objects_1"&gt;方法对象 ? Are functions objects?&lt;/h2&gt;
&lt;p&gt;将函式塞到对象中的原始动机是在 GUI 开发中.点击一个按钮时,一些代码(回调)就应该被触发. 为了指明按了具体哪个按钮,回调的函式就想要一个指代的对象. 因为回调就这么单纯,看起来将其存储在按钮中没有什么不好. 于是我们有了个”对象”. 的确挺方便. 但 GUI 应用只是个非常有限的情景,并不能真正证明 “一切皆对象”的普世性. 可惜计算机科学这种过度概括是常态.&lt;/p&gt;
&lt;p&gt;But even the above contains a subtle mistake: the callback in the button is not really a method. It is just a usual function. Very few procedures should be considered methods of an object, and most others are just functions. If you look carefully, most of the time the objects just serve as a namespace (or module) in which you can put data fields and functions. But those functions can also live on their own (such as addition of velocities or time). They just take the objects as inputs and produce some output. Only the functions that are most intimately connected to the fields and provide an “abstraction layer” should be considered methods. Most of those are “getters”, “setters” or “iterators”. Functions don’t necessarily belong to objects. They are not objects. They describe a change, transition or transformation of objects. They are external to the objects.&lt;/p&gt;
&lt;p&gt;但是，即使上述包含一个微妙的错误：在按钮的回调是不是一个真正的方法。这只是一个平常的功能。很少有程序应被视为一个对象的方法，而大多数人都只是功能。如果你仔细观察，大部分时间的对象只是作为一个命名空间（或模块）中，你可以把数据域和功能。但是，这些功能也可以生活在他们自己的（如加速度或时间）。他们只是把对象作为输入，并产生一些输出。只有那些最密切相关的领域，并提供了一个“抽象层”的功能，应考虑方法。其中大部分是“干将”，“二传手”或“迭代器”。功能不一定属于对象。他们不是对象。他们描述的改变，转变或物体的转型。它们是外部的对象。&lt;/p&gt;
&lt;p&gt;In some languages such as Scala or Python, functions are also treated as objects. But they actually just wrapped the functions into an object, give them some name such as “apply” or “&lt;strong&gt;call&lt;/strong&gt;”, so that when the objects are “invoked”, you know which functions to call. But putting a function into an object doesn’t really mean functions are also objects, just like inviting friends to your house doesn’t make them your family.&lt;/p&gt;
&lt;h2 id="the-cost-of-excessive-abstraction_1"&gt;The cost of excessive abstraction&lt;/h2&gt;
&lt;p&gt;The major appeal of OOP is abstraction, but OO programmers usually overdo it. I know the value of abstraction. I build abstractions every day, in all kinds of languages. But OOP advocates a level of abstraction which makes programs hard to understand and hard to analyze. I often see Java programs with multiple levels of inheritance and overloading but doing very little. And worse, because there are so much code that doesn’t do real things, it is very hard to find out which part of the code is doing the thing you want.&lt;/p&gt;
&lt;p&gt;Whenever you complain about Java or C++, OO proponents will tell you that they are not authentic OO languages. They would ask you to take a look at Smalltalk. If Smalltalk’s ways are that good, why almost nobody is using Smalltalk now? Because there are real problems in its approach. The “authentic” OO style of Smalltalk promotes the notion of “extremely late binding”, which basically means that the meaning of the program constructs is determined as late as possible.&lt;/p&gt;
&lt;p&gt;Late binding means that you have a chance to swap out the underlying implementation without forcing the upper levels to change, but it also means that you are no longer sure what a piece of code means! When I look at expressions such as ’1+2′ and ‘if (t) then … else …’ in Java or C++, I at least know for sure that they mean an integer addition and an usual conditional. But I’m not sure about this in an “extremely late binding language”, because even the meaning of ‘+’ and ‘if” can be redefined. A similar problem happens to Lisp family languages’ macro systems. It is bad idea of giving the programmers the power of defining control structures, because soon your language will be abundant of quirky control structures designed by programmers who try to be clever.&lt;/p&gt;
&lt;p&gt;Abstraction is a good idea when used moderately, but when you do it in excess, it backfires. Not only does it make it hard for humans to understand the code, it makes automated analysis tools and compiler optimizations difficult or impossible to make. I built an advanced static analysis tool for Python called PySonar. It works okay in general, but under the premise that the programs don’t use the “deep magic” of Python (which are possibly learned from Smalltalk). If you do, there are all sorts of ways you can confuse the analysis, but for that I can do nothing to help. Nothing can analyze or optimize the code if you put expensive or undecidable computations into the abstraction layer.&lt;/p&gt;
&lt;p&gt;So is there any value of making those deep abstractions an option but not encouraged to use by usual programmers? There might be, but probably too little to offset the lost safety guarantee and performance.&lt;/p&gt;
&lt;h2 id="everything-is-an-actor_1"&gt;Everything is an actor?&lt;/h2&gt;
&lt;p&gt;In his talk, Gilad Bracha disagrees with the FP hypes such as monads and pattern matching (with some good points), but he over-valued the ways of OOP and the actor model. From the blog posts he refers to, you can see that he thinks of the actor model as the “one true way”.&lt;/p&gt;
&lt;p&gt;I’m always wary of such notion as “one true way” or “everything is…” I actually read Carl Hewitt’s actor model paper a long time ago and also some of his other concepts such as Direct LogicTM (Yes, there is a trademark sign on it). I didn’t really appreciate the papers and his way of writing, with the “dedicated to some-big-names” headlines, trademark signs and grand claims.&lt;/p&gt;
&lt;p&gt;The actor model suffers from the same drawbacks of OOP as I mentioned: over-abstraction and lacking of general expressiveness. There is no way a human being or an automated system can effectively reason about the programs if you build them at way. It hides bugs. Although the actor model may be useful in some cases, it is not really expressive and simple enough to nicely capture all computations. It has too much application-specific logic (which is essentially OOP) built in, thus it is not at the same universal level as lambda calculus or Turing machines.&lt;/p&gt;
&lt;h1 id="the-stupidity-of-oo-design-patterns_1"&gt;The stupidity of OO design patterns&lt;/h1&gt;
&lt;p&gt;It may not be inherent in all OO languages, but OO design patterns (such names as Factory, Facade, Flyweight, Singleton, Visitor etc) have been the major source of over-complication and confusion. Their origin was mostly due to the dogma of “everything is an object” and the lack of high-order functions (or the correct implementation of them).&lt;/p&gt;
&lt;p&gt;The design patterns are completely nonsense to me and I never used them. When I first heard about them I was already a PhD student at Cornell doing some PL research. I was curious about the book’s fame and borrowed one from the library. But I soon found a mapping from all those weird names to the programming techniques I have been using all the time. I don’t understand how such a book as GoF can ever be published which contains nothing but just giving new and weird names to existing programming techniques that I use every day. If you say the purpose of writing this book is to “improve communication of programmers”, then I would write a book and give new names to air, water and all kinds of food, in order to “improve the communication of all human beings”.&lt;/p&gt;
&lt;p&gt;Peter Norvig gave a talk on design patterns in 1998 pointing out most of the design patterns will be “transparent” once you have first-class functions. He was too polite to call design patterns nonsense or stupid, but that’s implied.&lt;/p&gt;
&lt;p&gt;Every time I remove a design pattern (some other people made) from PySonar, the code becomes simpler and more manageable. I just removed the last visitor pattern a few days ago, and I felt so relieved. They gave me nothing but extra work when they existed. I can do anything, including a lot more advanced things than those provided by visitor patterns, but without using them.&lt;/p&gt;
&lt;p&gt;I owe my insights into design patterns to some functional programming people. If you really want to understand the essence of OO design patterns, and how NOT to use them, take a look at this little book other than the GoF one.&lt;/p&gt;
&lt;h1 id="what-the-heck-is-oo_1"&gt;What the heck is OO?&lt;/h1&gt;
&lt;p&gt;If some concepts of FP are white elephants, then most of the OO concepts are emperor’s new clothes.&lt;/p&gt;
&lt;p&gt;“OO” has never been a coherent concept. In the beginning it claims to be able to save the world by having all those nice things such as abstract data types, inheritance, overloading, encapsulation etc etc. As those marketing hypes fail one after another, OO supporters make excuses. They started to claim that some elements, such as inheritance, are not the true element of OO.&lt;/p&gt;
&lt;p&gt;The meaning of “object-oriented” is always vague and shifting. OO supporters can change the term’s meaning at any time to their advantages. You can be called an OO language at one moment, and then be called a non-OO language just a few minutes later, depending on what they need. When they need to claim that “OOP rules the world”, they would say that you are an OO language because you have something which contains both data fields and procedures, thus satisfying the definition of an “object”. When you are criticized by users for your shortcomings, they would say that you are not an OO language because you don’t have “extremely late binding” etc etc, …&lt;/p&gt;
&lt;h1 id="the-harm-of-oop_1"&gt;The harm of OOP&lt;/h1&gt;
&lt;p&gt;Although purely functional programming has a cult-like culture, it at least contains something we can learn. On the contrary, OOP is almost pure stupidity and cult. In comparison to the recent popularity of FP, OOP has been there longer, so the harm is much deeper. Some years ago, almost every language tried to be OO just because of it is a good marketing word that the companies were looking for. Later on, many companies bought the concept of so-called “OO design patterns” and write convoluted code, and only by now some of them realized that they were wrong.&lt;/p&gt;
&lt;p&gt;The harm of OO is deep into education. It is destroying computer science departments. Many colleges use OO languages such as Java as their introductory language, which cause the students’ failure to learn the most essential concepts of programming.&lt;/p&gt;
&lt;p&gt;In industry, OO hasn’t really proved its effectiveness with evidence. Good systems may be built in a “OO language”, but the code is often written by people who understand the problems of OO and don’t embrace “everything is an object” or “design patterns”. All the good programmers use workarounds in OO languages and are essentially writing in a style that’s not really OO. So some OO language and its tools may be pretty successful, but the OO style has largely failed.&lt;/p&gt;
&lt;p&gt;OO encourages code reusing, but we want something expressive, bug-free and fast. The OO style and OO design patterns produce convoluted code which confuses even its own author. Lots of times people can’t bear with the bugs but can’t understand the code, thus they end up rewriting the code on their own.&lt;/p&gt;
&lt;p&gt;The programming languages world has cared too much about styles, paradigms and code reusing, this is why such things as OO and design patterns can have a chance to fool lots of people. Styles and paradigms may help, but they don’t solve actual problems. There really is no such “one true way” to follow as some people believe. Not only that OOP will not rule the world, it will leave very little impact on the future of programming.&lt;/p&gt;
&lt;h2 id="_1"&gt;是也乎&lt;/h2&gt;
&lt;p&gt;对于 王珢, 关注了很久了,久到成为习惯了…
但是,认真翻译他翻越后的技术思考成果,还是第一次,可惜也只能用自个儿的语气来快译,真正涉及的所有技术细节,俺还没有能力逐一印证,俺也只是个期望知道个认同的结论,记忆下来,直接使用的那种知其然,不知所以然的家伙…&lt;/p&gt;
&lt;p&gt;但是,不得不说,对于 OOP 从第N次使用JAVA 败退后,就一直对 OOP 的编程思想抱有深深的焦虑,原先是对自个儿为毛无法自然的对象化所有事物而自我嫌弃,然后是奇怪为毛不用 OOP 编程反而更加自然,到最后,沈游侠向俺演示,怎么通过清除 class 关键词令脚本的代码更短,运行更快…彻底放弃了 OOP 俺的世界观,但是,一直没有找到为毛这样的根因,现在 王珢完成了这一结论性描述,收藏之!&lt;/p&gt;
&lt;h2 id="changlog"&gt;Changlog&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;140105 前后2小时翻译42%&lt;/li&gt;
&lt;li&gt;131224 翻越抄录在 medium.com&lt;/li&gt;
&lt;/ul&gt;</summary><category term="YinWang"></category><category term="Pythonner"></category><category term="Zh"></category></entry><entry><title>OSS good for enterprise</title><link href="http://blog.zoomquiet.io/imho/oss-good-4-china-com.html" rel="alternate"></link><updated>2013-11-11T00:00:00+08:00</updated><author><name>Zoom.Quiet</name></author><id>tag:blog.zoomquiet.io,2013-11-11:imho/oss-good-4-china-com.html</id><summary type="html">&lt;h1 id="oss"&gt;企业进行OSS的好处&lt;/h1&gt;
&lt;p&gt;&lt;code&gt;~中国绝大多数IT企业&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;img alt="oss" src="https://d262ilb51hltx0.cloudfront.net/max/700/1*2m0OBPBnBJu0WrobbfnBkg.png" /&gt;&lt;/p&gt;
&lt;p&gt;其实也是欠稿一篇, 先是忽悠朋友完成了作文:
&lt;a href="http://zhuanlan.zhihu.com/zhuangbiaowei/19576637"&gt;企业开源杂谈 — 思考IT — 知乎专栏&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;然后,又引发了系列讨论,结果变成了自个儿应该还的一篇文章,,,
同样的,由大脑自动后台组稿42天,快速输出一版本先:&lt;/p&gt;
&lt;h2 id="_1"&gt;背景:&lt;/h2&gt;
&lt;p&gt;首先, 俺自个儿, 社区称号:大妈, 入行以来加入N 多技术社区, 长年混杂在各种企业内外社区中,折腾,再折腾,从来没有什么成型的NB的流传于世或是企业生产系统中的项目…按照 Eric Raymond的著名文章:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;如何成为一名黒客
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;其中的定义,俺属于绝对意义上的大妈式 Hacker, 公布有效信息(文档/翻译)/维护维基/传播Hack 文化本身…&lt;/p&gt;
&lt;p&gt;然后,从业14年,从前台作到后台,作不动现代的全端工程师,掺合过的公司从4人到4000人的级别都有;近年,基本作 开发者关系管理(DRM), KPI 计算 40%开发,其它是社区活动的组织/筹备/主持/演讲/宣传/推广…&lt;/p&gt;
&lt;h2 id="_2"&gt;范畴&lt;/h2&gt;
&lt;p&gt;一篇文章绝对不可能将一个领域的发展问题分析明白的,所以,为了表述的健康/合理, 先定一下讨论的范畴,以免各种扩大化式的乱入.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;只说IT企业,即,主赢收业务是软件/互联网/移动/服务…etc.&lt;/li&gt;
&lt;li&gt;中国企业,无论注册地/资本来由/管理层国藉, 只论主要业务在中国大陆,主要开发者是中国本土码农…&lt;/li&gt;
&lt;li&gt;开源,就是标准的 FLOSS ~ 使用标准的许可证以及发布形式/维护过程 的 自由/开源软件, 因为开放源代码,对于 自由软件还是开源软件都是基本要求,只是后续发布的要求有差别,早已被中国媒体给搅合的说不清楚了,所以,一概论之了…&lt;/li&gt;
&lt;li&gt;因为职业原因,不便对老雇主或是现雇主泄漏什么内部机密,所以,只讨论,如同化学实验,嗯嗯嗯,,,精确的说,就象写 SiFi 小说一样推演,企业推行 OSS 的好处; 试图达到度目标就是能向一般的BOSS/同事,以极其常识的叙述来说明白,为什么应该 OSS, 至于坏处,就当没有吧,反正在中国没有什么正当的追究过程…&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id="_3"&gt;故事&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;从前有个公司,使用了开源软件,后来,嗯嗯嗯,就没有后来了!&lt;/li&gt;
&lt;li&gt;从前又一公司,开源了内部系统,然后,嗯嗯嗯,就没有然后了!&lt;/li&gt;
&lt;li&gt;从前还是一公司,从一开始就用开源软件的形式来专发,嗯嗯嗯,然后也没有然后了…&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id="_4"&gt;断语&lt;/h2&gt;
&lt;p&gt;嗯嗯嗯,共同之处就素:所有公司都玩一朝天子一朝臣,后人废掉前尘事儿! 大家都实在太习惯太顺畅太自说自话太自发自觉的作这类事儿了….其实,追点儿根儿,很简单,无论多重要,多NB 的代码,在公司中除了写那些代码的人,其余根本没有人能够/愿意/喜欢 真正理解这些要命的代码,而且最后竟然,就连代码原作者也都认同了这种”文化”随时抛弃无论当初花多少精力折腾出来的代码了…&lt;/p&gt;
&lt;p&gt;所以,企业真正进行开源工程式的产品开发,目测至少有这么几个方面是立即可以获得好处的:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;产品安全性立即获得极大的提高,因为所有人知道,代码都特么开源了,服务想安全,就得作到运行时,真正安全了!&lt;/li&gt;
&lt;li&gt;代码将真正为越来越多的人理解,从而所有工程师的工作将无法简单的通过行政命令抹杀,随着开源项目的不断扩散/衍生/复用,原作者的价值在不断增值!&lt;/li&gt;
&lt;li&gt;文档将被自主自发的不断完善,因为一个没有好文档的项目,本身再NB 也没人用!
测试将被自主自发的由开发者自个儿进行了,因为开源后,有太多自动化测试服务可以在外网自在的使用了,再也不用跟测试部的那帮XX叽歪了!&lt;/li&gt;
&lt;li&gt;开发人员的工作时间立即被自主自发的延长了! 因为开源工程受到关注后,全球用户可不管你们是否下班了,那 Issue 是随时捅过来的!&lt;/li&gt;
&lt;li&gt;项目维护人员免费增加了! 只要项目真正解决领域问题,那么公司自个儿都没有用到的场景也一定会有人用上,根据开源协议,人家也必须将修订提交回来…好了,免费的比自家公司还NB 的工程师为咱开始工作了!&lt;/li&gt;
&lt;li&gt;技术团队的业界形象立即加持圣光了! 以后招人,也就不用送MM 之类的下作手法了,只说来了能同 XX项目的原创程序员一起工作!&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;等等吧…就不逐一推导了…&lt;/p&gt;
&lt;h1 id="_5"&gt;但是!&lt;/h1&gt;
&lt;p&gt;以上的一切好处获得的前题是:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;进行真正的开源项目运行
坚持以纯粹的开源社区形式运营
公司的真实业务系统真正使用开源项目的代码
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;以及,其实隐藏在这三项基本坚持之下引发的各种
&lt;code&gt;管理/组织/绩效/人力&lt;/code&gt; 等等的配套支撑.&lt;/p&gt;
&lt;p&gt;所以, 只能是SiFi 式的推导了…因为中国IT 企业天生的同开源社区式开发有内在的抵触…具体的,大家都懂的,不用俺费劲分析了卟?!&lt;/p&gt;
&lt;h2 id="_6"&gt;所以&lt;/h2&gt;
&lt;p&gt;友人收作业后反馈,肿么没有后续了? 比如遭遇各种反驳，如何进一步攻防之类…&lt;/p&gt;
&lt;p&gt;&lt;code&gt;图样儿图森破!&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;在公司里,不遭受质疑那是不可能的!&lt;/p&gt;
&lt;p&gt;但是,有质疑就进行反驳…你以为你是方舟子对韩寒哪!&lt;/p&gt;
&lt;p&gt;企业进行开源,无非两种推行模式: &lt;code&gt;嬴政式&lt;/code&gt;/&lt;code&gt;吴广式&lt;/code&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;前者,BOSS 就是开源出身,先信了,强行推之,整个公司所有部门为之配合,反正败了BOSS 自个儿负责,然后,慢慢品出了好处,于是更加大力在实践中学习再学习,在学习中感动再感动…慢慢的,公司如果不死,那就真正形成文化传承下去了,否则就变成业界又一SB 传说…&lt;/li&gt;
&lt;li&gt;后者,习惯了开源开发方式了,瞒着公司,将自个儿一亩三分田先折腾起来,慢慢的,慢慢的对比其它同类团队的同类系统,肿么这么出名呢? 靠! 原来这丫开源了! 然后,没有然后了,不是被掐掉,就是这团队解散了…&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;所以? 这些好处,多数情况,要不根本无从质疑 (BOSS稀饭!-) , 要不根本轮不到质疑,也就没有什么反击之说了…&lt;/p&gt;
&lt;p&gt;其实! 公司里的质疑,根本没有质疑的任何意思在里面,无非是责任推卸:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;”我早就质疑过的哟,只是这丫不听,所以,没俺一毛钱关系!”
“看吧! 要不是早先我质疑过,他们才改进,现在肿么可能成功?!”
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;所以? 有质疑时,只要你勇敢的担当下来,没人有空跟你分析什么协议的…&lt;/p&gt;
&lt;p&gt;所以! 在企业里推进OSS, 最最最低程度,你得是个有足够话语权的强力团队头目,或领域技术带头人…&lt;/p&gt;
&lt;p&gt;不过,一般在这种地位上,都要担营收的KPI, 需要接销售各种奇葩的单子,哪儿有空搞 OSS 运动哪…&lt;/p&gt;
&lt;p&gt;所以,俺反复说了是 &lt;code&gt;SiFi&lt;/code&gt; 式的推理呢…&lt;/p&gt;
&lt;h2 id="changelog"&gt;Changelog&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;140107 move into Pelican as zoomquiet.io&lt;/li&gt;
&lt;li&gt;131114 增补后续地图炮&lt;/li&gt;
&lt;li&gt;131112 初放 &lt;a href="https://medium.com/i-m-h-o/74caad149e7e"&gt;企业进行OSS的好处 — I. M. H. O. — Medium&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</summary><category term="OSS"></category><category term="Think"></category><category term="China"></category></entry><entry><title>Collections and Embedded Documents in MongoDB</title><link href="http://blog.zoomquiet.io/imho/mongo-collections-embdded-think.html" rel="alternate"></link><updated>2013-10-27T00:00:00+08:00</updated><author><name>Zoom.Quiet</name></author><id>tag:blog.zoomquiet.io,2013-10-27:imho/mongo-collections-embdded-think.html</id><summary type="html">&lt;h1 id="mongodb"&gt;MongoDB 中的集合或嵌入式文档&lt;/h1&gt;
&lt;p&gt;&lt;img alt="mongo" src="https://d262ilb51hltx0.cloudfront.net/max/700/1*cwCnTFQEbcUSy1KvoiIqXg.png" /&gt;&lt;/p&gt;
&lt;p&gt;[via] http://fosterelli.co/collections-and-embedded-documents-in-mongodb.html&lt;/p&gt;
&lt;p&gt;When someone is approaching MongoDB from the SQL world, a very common confusion regarding database structure is when to use embedded documents, and when to create an entirely new collection. This distinction is very important because, although MongoDB is schemaless in nature, whether or not an element of your database is structured as embedded documents or a separate collection will change your code a fair amount. Making this change later on can represent a fair amount of work, so it helps to get this right the first time.&lt;/p&gt;
&lt;p&gt;There is no “right answer” to this question, as it depends entirely on the situation at hand. The natural tendency of people coming from the SQL world is to stick everything in separate collections, but often this is very unnecessary and will cause serious performance impacts. However, mistakenly placing something within another document may lead to pain further down the road.&lt;/p&gt;
&lt;p&gt;A set of rules I have found useful is to ask yourself the following questions:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Does the embedded document relate to one or more other collections?&lt;/li&gt;
&lt;li&gt;Will you most often need the embedded document without the parent document?&lt;/li&gt;
&lt;li&gt;Will you most often need the parent document without the embedded document?&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;If the answer to two or more of these is yes, you likely will want a separate collection. If the answer to only one of these is yes, a separate collection should still be considered, but likely not needed.&lt;/p&gt;
&lt;h2 id="examples"&gt;Examples&lt;/h2&gt;
&lt;h3 id="comments-on-a-blog"&gt;Comments on a blog&lt;/h3&gt;
&lt;p&gt;You would like to create a system where people may submit comments on blog posts. The problem is that you are unsure if you should store the comment on the post document, or create a separate collection named comments.&lt;/p&gt;
&lt;h4 id="does-the-embedded-document-relate-to-one-or-more-other-collections"&gt;Does the embedded document relate to one or more other collections?&lt;/h4&gt;
&lt;p&gt;No. A comment is typically related to only the post that it is commented on. There may be some situations where this is not true, such as if you provided comment author accounts for editing. However, even this is not a very convincing reason by itself to separate the comment into a separate collection.&lt;/p&gt;
&lt;h4 id="will-you-most-often-need-the-embedded-document-without-the-parent-document"&gt;Will you most often need the embedded document without the parent document?&lt;/h4&gt;
&lt;p&gt;Again, the answer is no. You likely will not often need to load a comment without also needing the context of the post.&lt;/p&gt;
&lt;h4 id="will-you-most-often-need-the-parent-document-without-the-embedded-document"&gt;Will you most often need the parent document without the embedded document?&lt;/h4&gt;
&lt;p&gt;In the majority of cases, the answer here is no. Most of the time you use this object, someone will be viewing a blog entry. You will want to both display the post and the comments at once, so it makes sense to fetch those together.&lt;/p&gt;
&lt;p&gt;Overall, comments for a blog is a very good candidate for embedded documents.&lt;/p&gt;
&lt;h3 id="students-in-a-class"&gt;Students in a class&lt;/h3&gt;
&lt;p&gt;You have a school management system, and you would like to enable students to enrol in a particular class. You are unsure if you should store the student objects on the class, or create a separate collection named students.&lt;/p&gt;
&lt;h4 id="does-the-embedded-document-relate-to-one-or-more-other-collections_1"&gt;Does the embedded document relate to one or more other collections?&lt;/h4&gt;
&lt;p&gt;Typically, we can assume yes. A student will likely relate to other things, such as an assignment or school object. Also, a very important note is that each embedded document will likely relate to multiple documents in the classes collection, which is a very strong hint you need a separate collection.&lt;/p&gt;
&lt;h3 id="3-will-you-most-often-need-the-embedded-document-without-the-parent-document"&gt;3 Will you most often need the embedded document without the parent document?&lt;/h3&gt;
&lt;p&gt;The answer here will often be yes. If you want any sort of student information panel or want to have students enrolled in different classes, then you will often want the student document without needing the context of each class.&lt;/p&gt;
&lt;h4 id="will-you-most-often-need-the-parent-document-without-the-embedded-document_1"&gt;Will you most often need the parent document without the embedded document?&lt;/h4&gt;
&lt;p&gt;Probably no for this one. It depends on what operation we are doing most often with the class, but I imagine that when we fetch a class we would likely need at least one student as well.&lt;/p&gt;
&lt;p&gt;Overall, students in a class are probably better suited for a separate collection. It’s important to keep in mind the scope of the problem you are solving with the data, and the operations that will be done most commonly. That said, a student is a very relational piece of data and better fits a separate collection.&lt;/p&gt;
&lt;blockquote&gt;
&lt;blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;尝试翻译为中文:&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/blockquote&gt;
&lt;/blockquote&gt;
&lt;p&gt;如果刚刚从SQL 世界进入 MongoDB, 最常见的困惑就是 “嵌入式文档” 以及何时创建新的”集合”?
这类困惑的根源就是还没有建立起来 MongoDB 的自由结构世界观 ;-)
SQL 世界的来客,总是试图先建立起一个完美的关系体系可以兼容以后的所有业务变化, 而 Mongo们,则是更加愿意先将已知的数据舒服的收集起来,随着业务的理解,不断的调整结构,同时代码永远可用!&lt;/p&gt;
&lt;p&gt;那么,这里给出俺知道的判定问题:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;嵌入的文档,同其它集合有一个或以上的关联嘛?&lt;/li&gt;
&lt;li&gt;你将总会请求嵌入的文档,而 不需要 父文档嘛?&lt;/li&gt;
&lt;li&gt;你将总会请求父文档,而 不需要 嵌入的文档嘛?&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;如果以上问题,有两个或以上回答为 yes, 那么最好使用独立的集合.
如果回答只有一个为 yes, 那么独立集合也应该考虑,但一般不必要了.&lt;/p&gt;
&lt;h2 id="_1"&gt;示例&lt;/h2&gt;
&lt;h3 id="blog"&gt;blog 的评注&lt;/h3&gt;
&lt;p&gt;你可能创建过类似blog 的系统,允许用户创建评注.问题在于你无法确定这堆评注,是存储在文章对象中呢,还是另外创建集合来保存?
动用以上问题来考查一下…&lt;/p&gt;
&lt;h4 id="_2"&gt;嵌入的文档,同其它集合有一个或以上的关联嘛?&lt;/h4&gt;
&lt;p&gt;首先呢,评注肯定是先同当前文章有关联的. 同时也有很多其它方案, 比如想支持作者可以修订评注. 但是,这还不足以今评注分离成独立集合.&lt;/p&gt;
&lt;p&gt;你将总会请求嵌入的文档,而 不需要 父文档嘛?&lt;/p&gt;
&lt;p&gt;再来,如果这问题的回答是 否. 意味着你并不想加载文章时,一定就显示评注.&lt;/p&gt;
&lt;h4 id="_3"&gt;你将总会请求父文档,而 不需要 嵌入的文档嘛?&lt;/h4&gt;
&lt;p&gt;多数情况,这个问题的回答是 否. 一般只是想显示文章, 只是有时,期望同时显示, 那就必须让这一动作简单.&lt;/p&gt;
&lt;p&gt;综上, 评注作为 嵌入文档 是合理的.&lt;/p&gt;
&lt;h2 id="_4"&gt;班级中的学生&lt;/h2&gt;
&lt;p&gt;你有个学校管理系统, 想让学生作为特殊的一个类, 但是,不肯定是作为班级的嵌入文档呢, 还是独立集合.&lt;/p&gt;
&lt;h4 id="_5"&gt;嵌入的文档,同其它集合有一个或以上的关联嘛?&lt;/h4&gt;
&lt;p&gt;典型的,我们回答 是 . 每个学生总是会关联各种事物, 比如学校.同时,重要的每个嵌入文档同多个班级有关系时,这是分离为单独集合的重要暗示.&lt;/p&gt;
&lt;h4 id="_6"&gt;你将总会请求嵌入的文档,而 不需要 父文档嘛?&lt;/h4&gt;
&lt;p&gt;这问题经常回答为 是. 如果你想对学生进行多种排序,或是不同班级有不同学生参加,所以你总是想使用 学生节点而不是班级的信息.&lt;/p&gt;
&lt;h4 id="_7"&gt;你将总会请求父文档,而 不需要 嵌入的文档嘛?&lt;/h4&gt;
&lt;p&gt;这问题可能就是 否了. 这取决于我们经常怎么使用班级的数据, 目测其实我们最常查询班级的数据就是最后那名学生是谁.&lt;/p&gt;
&lt;p&gt;综上,班级学生最好分离为独立的集合. 重要的是问题域要关注你的数据,并且令数据分布吻合常见事务要求. 即, 学生关联那多数据,最好独立!&lt;/p&gt;
&lt;p&gt;that all!&lt;/p&gt;
&lt;p&gt;其实, 使用文档型NoSQL, 特别是 MongoDB, 放弃RMDB 那堆范式的概念,使用我们的直觉,从当前已知的常见操作出现来设计文档结构就对了!&lt;/p&gt;
&lt;h2 id="changelog"&gt;Changelog&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;140107 move into Pelican as zoomquiet.io&lt;/li&gt;
&lt;li&gt;131027 pub. &lt;a href="https://medium.com/i-m-h-o/c161d7036f89"&gt;Collections and Embedded Documents in MongoDB — I. M. H. O. — Medium&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</summary><category term="NoSQL"></category><category term="Mongo"></category><category term="Zh"></category></entry></feed>